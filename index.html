<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=240, height=282, initial-scale=1, maximum-scale=1" />
  <title>Sunrise / Sunset Clock â€” r1 creation</title>
  <style>
    :root{--w:240px;--h:282px}
    html,body{height:100%;margin:0;font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial;}
    body{background:#000;display:flex;align-items:center;justify-content:center}
    #app{width:var(--w);height:var(--h);overflow:hidden;border-radius:20px;position:relative;backdrop-filter:blur(20px) saturate(180%);background:rgba(255,255,255,0.06);box-shadow:0 8px 30px rgba(0,0,0,0.35)}

    .bg{position:absolute;inset:0;transition:background 1200ms linear, opacity 800ms linear;z-index:-1}
    .stars{position:absolute;inset:0;pointer-events:none;opacity:0;transition:opacity 1200ms ease-in-out;z-index:0}
    .star{position:absolute;width:2px;height:2px;background:white;border-radius:50%;opacity:0.8;}

    .symbol{position:absolute;top:10px;right:10px;font-size:14px;color:#fff;opacity:0;transition:opacity 300ms ease-in-out;}

    .content{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none;z-index:1}
    .city{font-size:12px;color:#fff;margin-bottom:4px;cursor:pointer;pointer-events:auto;text-decoration:underline;}
    .time{font-size:44px;line-height:1;font-weight:600;color:rgba(255,255,255,0.96);text-shadow:0 2px 12px rgba(0,0,0,0.45);transition:transform 280ms cubic-bezier(.2,.9,.2,1),opacity 220ms}
    .date{font-size:12px;margin-top:6px;color:rgba(255,255,255,0.85);opacity:0.95}
    .temp{font-size:12px;color:rgba(255,255,255,0.8);margin-top:2px;}

    .footer{position:absolute;bottom:58px;width:100%;text-align:center;font-size:10px;color:rgba(255,255,255,0.7);pointer-events:none}
    .daylight-graph{position:absolute;bottom:0;left:0;width:100%;height:50px;}
    .pop{transform:translateY(-6px) scale(1.02)}

    /* Frosted glass overlay for city selection */
    .overlay{position:absolute;inset:0;backdrop-filter:blur(20px) saturate(180%);background:rgba(255,255,255,0.08);display:flex;flex-direction:column;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity 300ms ease-in-out;}
    .overlay.show{opacity:1;pointer-events:auto;}
    .overlay input{background:rgba(255,255,255,0.15);border:none;border-radius:8px;color:#fff;font-size:14px;width:70%;text-align:center;outline:none;padding:6px;backdrop-filter:blur(10px);}
    .overlay button{margin-top:10px;padding:6px 12px;font-size:12px;border:none;background:rgba(255,255,255,0.85);color:#000;border-radius:8px;cursor:pointer;}

    @media (prefers-reduced-motion: reduce){
      .bg, .time{transition:none}
    }
  </style>
</head>
<body>
  <div id="app" role="application" aria-label="Sunrise Sunset Clock">
    <div id="bg" class="bg"></div>
    <div id="stars" class="stars"></div>
    <div id="symbol" class="symbol"></div>
    <div class="content">
      <div id="city" class="city">Loading cityâ€¦</div>
      <div id="time" class="time">--:--</div>
      <div id="date" class="date">Loadingâ€¦</div>
      <div id="temp" class="temp"></div>
    </div>
    <canvas id="daylightGraph" class="daylight-graph"></canvas>
    <div class="footer">Scroll to scrub â€” PTT/Space to snap sunrise/sunset</div>
    <div id="overlay" class="overlay">
      <input id="cityInput" type="text" placeholder="Enter city" />
      <button id="citySubmit">Set City</button>
    </div>
  </div>

  <script>
    (function(){
      const app = document.getElementById('app');
      const bg = document.getElementById('bg');
      const starsEl = document.getElementById('stars');
      const symbolEl = document.getElementById('symbol');
      const timeEl = document.getElementById('time');
      const dateEl = document.getElementById('date');
      const tempEl = document.getElementById('temp');
      const cityEl = document.getElementById('city');
      const overlay = document.getElementById('overlay');
      const cityInput = document.getElementById('cityInput');
      const citySubmit = document.getElementById('citySubmit');
      const daylightGraph = document.getElementById('daylightGraph');
      const ctx = daylightGraph.getContext('2d');

      let config = {
        minutesPerTick: 15,
        bgTransitionMs: 1200
      };

      let now = new Date();
      let virtualMinutes = now.getHours()*60 + now.getMinutes() + now.getSeconds()/60;
      let virtualDayOffset = 0;
      let liveMode = false;
      let cityName = "Your City";
      let timezone = "UTC";

      // Store sun data for multiple days
      let sunData = [];
      let currentLat = 40.7128; // Default to NYC
      let currentLon = -74.0060;

      // Get current sunrise/sunset for the virtual time
      function getCurrentSunTimes() {
        const dayIndex = Math.max(0, Math.min(sunData.length - 1, virtualDayOffset + 2)); // Center day
        return sunData[dayIndex] || { sunrise: 6*60, sunset: 18*60 };
      }

      async function fetchSunTimes(city){
        try{
          const geo = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(city)}`).then(r=>r.json());
          if(!geo[0]) return;
          
          currentLat = parseFloat(geo[0].lat);
          currentLon = parseFloat(geo[0].lon);
          cityName = geo[0].display_name.split(",")[0];
          cityEl.textContent = cityName;

          // Fetch sun data for 7 days (3 before, current, 3 after)
          sunData = [];
          const promises = [];
          
          for(let i = -3; i <= 3; i++) {
            const date = new Date();
            date.setDate(date.getDate() + i);
            const dateStr = date.toISOString().split('T')[0];
            
            promises.push(
              fetch(`https://api.sunrise-sunset.org/json?lat=${currentLat}&lng=${currentLon}&date=${dateStr}&formatted=0`)
                .then(r => r.json())
                .then(sun => {
                  if(sun.status === "OK") {
                    // Convert to local time
                    const sunriseDate = new Date(sun.results.sunrise);
                    const sunsetDate = new Date(sun.results.sunset);
                    
                    return {
                      date: dateStr,
                      sunrise: sunriseDate.getHours() * 60 + sunriseDate.getMinutes(),
                      sunset: sunsetDate.getHours() * 60 + sunsetDate.getMinutes(),
                      daylight: (sunsetDate - sunriseDate) / (1000 * 60) // minutes of daylight
                    };
                  }
                  return { sunrise: 6*60, sunset: 18*60, daylight: 12*60 };
                })
                .catch(() => ({ sunrise: 6*60, sunset: 18*60, daylight: 12*60 }))
            );
          }

          sunData = await Promise.all(promises);

          // Fetch weather
          const weather = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${currentLat}&longitude=${currentLon}&daily=temperature_2m_max,temperature_2m_min&timezone=auto`).then(r=>r.json());
          if(weather && weather.daily){
            const max = weather.daily.temperature_2m_max[0];
            const min = weather.daily.temperature_2m_min[0];
            tempEl.textContent = `H:${Math.round(max)}Â° L:${Math.round(min)}Â°`;
          }

          drawDaylightGraph();

        }catch(e){
          console.error("Failed to fetch sun/weather",e);
          // Fallback data
          sunData = Array(7).fill().map(() => ({ sunrise: 6*60, sunset: 18*60, daylight: 12*60 }));
          drawDaylightGraph();
        }
      }

      function drawDaylightGraph(){
        const dpr = window.devicePixelRatio || 1;
        const rect = daylightGraph.getBoundingClientRect();
        daylightGraph.width = rect.width * dpr;
        daylightGraph.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        
        const w = rect.width;
        const h = rect.height;
        
        ctx.clearRect(0, 0, w, h);

        if(sunData.length === 0) return;

        // Draw elliptical arc (dotted baseline representing 24 hours)
        const centerX = w / 2;
        const centerY = h + 30; // Center below canvas for ellipse
        const radiusX = w * 0.55; // Wider horizontal radius
        const radiusY = h * 1.2;  // Taller vertical radius for elliptical shape
        
        // Draw dotted ellipse arc (midnight to midnight)
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.setLineDash([3, 6]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        
        // Use ellipse method for smoother arc
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(1, radiusY / radiusX); // Scale to create ellipse
        ctx.arc(0, 0, radiusX, Math.PI, 0); // Draw semicircle, scaled to ellipse
        ctx.restore();
        ctx.stroke();

        // Get current day's sun data - fix the day calculation
        const currentDayIndex = 3; // Center day in our 7-day array
        const dayOffset = Math.max(-3, Math.min(3, virtualDayOffset)); // Clamp to our available range
        const actualDayIndex = currentDayIndex + dayOffset;
        const data = sunData[actualDayIndex] || sunData[currentDayIndex] || { sunrise: 6*60, sunset: 18*60 };
        
        // Convert times to angles (midnight=Ï€, noon=Ï€/2, midnight=0)
        const sunriseAngle = Math.PI - (data.sunrise / (24 * 60)) * Math.PI;
        const sunsetAngle = Math.PI - (data.sunset / (24 * 60)) * Math.PI;
        const currentTimeAngle = Math.PI - (virtualMinutes / (24 * 60)) * Math.PI;
        
        // Draw daylight arc (solid white line from sunrise to sunset)
        ctx.setLineDash([]);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        // Draw elliptical daylight arc
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(1, radiusY / radiusX);
        ctx.arc(0, 0, radiusX, sunriseAngle, sunsetAngle);
        ctx.restore();
        ctx.stroke();
        
        // Add glow effect to daylight arc
        ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
        ctx.shadowBlur = 8;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(1, radiusY / radiusX);
        ctx.arc(0, 0, radiusX, sunriseAngle, sunsetAngle);
        ctx.restore();
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Calculate marker positions (need to account for ellipse scaling)
        const sunriseX = centerX + Math.cos(sunriseAngle) * radiusX;
        const sunriseY = centerY + Math.sin(sunriseAngle) * radiusY;
        const sunsetX = centerX + Math.cos(sunsetAngle) * radiusX;
        const sunsetY = centerY + Math.sin(sunsetAngle) * radiusY;
        
        // Sunrise marker
        ctx.fillStyle = 'rgba(255, 200, 80, 0.9)';
        ctx.beginPath();
        ctx.arc(sunriseX, sunriseY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Sunset marker
        ctx.fillStyle = 'rgba(255, 120, 80, 0.9)';
        ctx.beginPath();
        ctx.arc(sunsetX, sunsetY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw current time indicator
        const currentX = centerX + Math.cos(currentTimeAngle) * radiusX;
        const currentY = centerY + Math.sin(currentTimeAngle) * radiusY;
        
        // Current time marker with glow
        ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
        ctx.shadowBlur = 6;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.beginPath();
        ctx.arc(currentX, currentY, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Add inner ring for current time
        ctx.fillStyle = 'rgba(100, 150, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(currentX, currentY, 2.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Add time labels at key positions
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '9px Inter, sans-serif';
        ctx.textAlign = 'center';
        
        // Midnight labels
        const leftMidnightX = centerX + Math.cos(Math.PI) * radiusX;
        const leftMidnightY = centerY + Math.sin(Math.PI) * radiusY;
        const rightMidnightX = centerX + Math.cos(0) * radiusX;
        const rightMidnightY = centerY + Math.sin(0) * radiusY;
        
        ctx.fillText('00:00', leftMidnightX, leftMidnightY + 12);
        ctx.fillText('00:00', rightMidnightX, rightMidnightY + 12);
        
        // Noon label  
        const noonX = centerX + Math.cos(Math.PI/2) * radiusX;
        const noonY = centerY + Math.sin(Math.PI/2) * radiusY;
        ctx.fillText('12:00', noonX, noonY - 8);
      }

      function lerpColor(a,b,f){return a.map((v,i)=>Math.round(v + (b[i]-v)*f));}
      function rgbToCss(r){ return 'rgb('+r.join(',')+')'; }

      function gradientForMinutes(min){
        const t = (min%1440 + 1440)%1440;
        const sunTimes = getCurrentSunTimes();
        const sunrise = sunTimes.sunrise;
        const sunset = sunTimes.sunset;
        
        // More accurate transition periods
        const dawnStart = sunrise - 90; // 1.5 hours before sunrise
        const dawnEnd = sunrise + 30;   // 30 min after sunrise
        const duskStart = sunset - 30;  // 30 min before sunset
        const duskEnd = sunset + 90;    // 1.5 hours after sunset

        const NIGHT_TOP = [8, 12, 28];
        const NIGHT_BOTTOM = [0, 0, 8];
        const DAWN_TOP = [255, 140, 80];
        const DAWN_BOTTOM = [255, 190, 140];
        const DAY_TOP = [120, 180, 255];
        const DAY_BOTTOM = [180, 220, 255];
        const SUNSET_TOP = [255, 100, 70];
        const SUNSET_BOTTOM = [255, 160, 100];

        let top, bottom;
        
        if(t >= dawnStart && t <= dawnEnd){
          const f = Math.max(0, Math.min(1, (t - dawnStart) / (dawnEnd - dawnStart)));
          const easeF = 1 - Math.pow(1 - f, 2); // Ease out
          top = lerpColor(NIGHT_TOP, DAWN_TOP, easeF);
          bottom = lerpColor(NIGHT_BOTTOM, DAWN_BOTTOM, easeF);
        } else if(t > dawnEnd && t < duskStart){
          const f = Math.max(0, Math.min(1, (t - dawnEnd) / (duskStart - dawnEnd)));
          const easeF = f < 0.5 ? 2 * f * f : 1 - Math.pow(-2 * f + 2, 2) / 2; // Ease in-out
          top = lerpColor(DAWN_TOP, DAY_TOP, easeF);
          bottom = lerpColor(DAWN_BOTTOM, DAY_BOTTOM, easeF);
        } else if(t >= duskStart && t <= duskEnd){
          const f = Math.max(0, Math.min(1, (t - duskStart) / (duskEnd - duskStart)));
          const easeF = f * f; // Ease in
          top = lerpColor(DAY_TOP, SUNSET_TOP, easeF);
          bottom = lerpColor(DAY_BOTTOM, SUNSET_BOTTOM, easeF);
        } else {
          // Night time - handle wrapping around midnight
          let f;
          if(t > duskEnd) {
            f = (t - duskEnd) / (1440 + dawnStart - duskEnd);
          } else {
            f = (1440 - duskEnd + t) / (1440 + dawnStart - duskEnd);
          }
          f = Math.max(0, Math.min(1, f));
          const easeF = 1 - Math.pow(1 - f, 2); // Ease out
          top = lerpColor(SUNSET_TOP, NIGHT_TOP, easeF);
          bottom = lerpColor(SUNSET_BOTTOM, NIGHT_BOTTOM, easeF);
        }
        
        return `linear-gradient(180deg, ${rgbToCss(top)} 0%, ${rgbToCss(bottom)} 100%)`;
      }

      function renderTime(min){
        const minutes = Math.floor((min % 1440 + 1440) % 1440);
        const h = Math.floor(minutes / 60);
        const m = minutes % 60;
        timeEl.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
        
        const d = new Date();
        d.setDate(d.getDate() + virtualDayOffset);
        dateEl.textContent = d.toLocaleDateString(undefined, {weekday:'short', month:'short', day:'numeric'});
      }

      function updateBackground(min){
        const g = gradientForMinutes(min);
        bg.style.background = g;
        
        const sunTimes = getCurrentSunTimes();
        const t = (min % 1440 + 1440) % 1440;
        const night = (t < sunTimes.sunrise - 30) || (t > sunTimes.sunset + 60);
        starsEl.style.opacity = night ? 0.8 : 0;
        
        drawDaylightGraph(); // Update graph with current position
      }

      function tick(){
        if(liveMode){
          const d = new Date();
          virtualMinutes = d.getHours() * 60 + d.getMinutes() + d.getSeconds() / 60;
          virtualDayOffset = 0;
          renderTime(virtualMinutes);
          updateBackground(virtualMinutes);
        }
        requestAnimationFrame(tick);
      }
      tick();

      function adjustMinutes(delta){
        const before = Math.floor(virtualMinutes / 1440);
        virtualMinutes += delta;
        const after = Math.floor(virtualMinutes / 1440);
        virtualDayOffset += (after - before);
        virtualMinutes = (virtualMinutes % 1440 + 1440) % 1440;
        renderTime(virtualMinutes);
        updateBackground(virtualMinutes);

        const cur = Math.round(virtualMinutes);
        const sunTimes = getCurrentSunTimes();
        if(Math.abs(cur - sunTimes.sunrise) < config.minutesPerTick / 2){
          showSymbol('â˜€ï¸');
        } else if(Math.abs(cur - sunTimes.sunset) < config.minutesPerTick / 2){
          showSymbol('ðŸŒ™');
        }
      }

      function snapToNext(){
        const cur = Math.floor((virtualMinutes % 1440 + 1440) % 1440);
        const sunTimes = getCurrentSunTimes();
        const events = [sunTimes.sunrise, sunTimes.sunset, sunTimes.sunrise + 1440];
        for(let e of events){
          if(e > cur){
            animateTo(e % 1440, Math.floor(e / 1440));
            break;
          }
        }
      }

      function animateTo(targetMin, dayIncrement = 0){
        liveMode = false;
        const start = virtualMinutes;
        const startDayOffset = virtualDayOffset;
        let delta = ((targetMin - start + 1440 + 720) % 1440) - 720;
        const duration = 1000;
        const startTs = performance.now();
        
        function step(ts){
          const t = Math.min((ts - startTs) / duration, 1);
          const ease = 1 - Math.pow(1 - t, 3);
          virtualMinutes = start + delta * ease;
          if(t === 1) virtualDayOffset = startDayOffset + dayIncrement;
          renderTime(virtualMinutes);
          updateBackground(virtualMinutes);
          if(t < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      }

      function onScroll(direction){
        liveMode = false;
        if(direction === 'up') adjustMinutes(config.minutesPerTick);
        else adjustMinutes(-config.minutesPerTick);
      }

      // R1 hardware events
      window.addEventListener('scrollUp', () => onScroll('up'));
      window.addEventListener('scrollDown', () => onScroll('down'));
      window.addEventListener('sideClick', () => { snapToNext(); });

      // Fallback for development/testing
      window.addEventListener('keydown', (e) => {
        if(e.code === "Space"){ e.preventDefault(); snapToNext(); }
        if(e.code === "ArrowUp"){ e.preventDefault(); onScroll('up'); }
        if(e.code === "ArrowDown"){ e.preventDefault(); onScroll('down'); }
      });

      let wheelAccum = 0;
      window.addEventListener('wheel', (e) => {
        wheelAccum += e.deltaY;
        const threshold = 50;
        if(wheelAccum > threshold){ onScroll('down'); wheelAccum = 0; }
        else if(wheelAccum < -threshold){ onScroll('up'); wheelAccum = 0; }
        e.preventDefault();
      }, {passive: false});

      app.addEventListener('click', () => {
        liveMode = !liveMode;
        app.classList.add('pop');
        setTimeout(() => app.classList.remove('pop'), 220);
      });

      cityEl.addEventListener('click', () => {
        overlay.classList.add('show');
        cityInput.value = cityName;
        cityInput.focus();
      });

      citySubmit.addEventListener('click', async() => {
        const newCity = cityInput.value.trim();
        if(newCity){
          overlay.classList.remove('show');
          cityEl.textContent = "Loadingâ€¦";
          await fetchSunTimes(newCity);
        }
      });

      cityInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter') {
          citySubmit.click();
        }
      });

      renderTime(virtualMinutes);
      updateBackground(virtualMinutes);
      cityEl.textContent = cityName;

      function generateStars(){
        const count = 35;
        for(let i = 0; i < count; i++){
          const star = document.createElement('div');
          star.className = 'star';
          star.style.top = Math.random() * 100 + '%';
          star.style.left = Math.random() * 100 + '%';
          star.style.opacity = Math.random() * 0.8 + 0.2;
          star.style.transform = `scale(${Math.random() * 1.2 + 0.6})`;
          starsEl.appendChild(star);
        }
      }
      generateStars();

      function showSymbol(sym){
        symbolEl.textContent = sym;
        symbolEl.style.opacity = 1;
        setTimeout(() => { symbolEl.style.opacity = 0; }, 1500);
      }

      // Initial fetch with default city
      fetchSunTimes("New York");
    })();
  </script>
</body>
</html>